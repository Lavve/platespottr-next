This project uses Next, React, TypeScript and MUI, all latest versions or close to

## Cursor Rules

- When a specific line is referenced, focus only on that line and its immediate context
- Do not make changes to unrelated parts of the file
- Do not suggest changes to the entire file unless explicitly requested
- When a line number is provided, use it as the primary context for the response
- Keep responses focused on the specific line and its direct dependencies

## Cursor Prefix System

- Use "CURSOR: " prefix in messages to enforce strict cursor rule compliance
- When "CURSOR: " is used, responses must focus only on the referenced line and its immediate context
- The prefix acts as a trigger to enforce the most strict interpretation of cursor rules
- Example: "CURSOR: What's wrong with this line?"

## Constants Over Magic Numbers

- Replace hard-coded values with named constants
- Use descriptive constant names that explain the value's purpose
- Keep constants at the top of the file or in a dedicated constants file

## Meaningful Names

- Variables, functions, and classes should reveal their purpose
- Names should explain why something exists and how it's used
- Avoid abbreviations unless they're universally understood

## Smart Comments

- Don't comment on what the code does - make the code self-documenting
- Use comments to explain why something is done a certain way

## DRY (Don't Repeat Yourself)

- Extract repeated code into reusable functions
- Share common logic through proper abstraction
- Maintain single sources of truth

## Clean Structure

- Keep related code together
- Organize code in a logical hierarchy
- Use consistent file and folder naming conventions

## Code Quality Maintenance

- Refactor continuously
- Fix technical debt early
- Leave code cleaner than you found it

## Version Control

- Write short but clear commit messages
- Make small, focused commits
- Use meaningful branch names

## Verify Information

- Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.

## File-by-File Changes

- Make changes file by file and give me a chance to spot mistakes.

## No Apologies

- Never use apologies.

## No Understanding Feedback

- Avoid giving feedback about understanding in comments or documentation.

## No Whitespace Suggestions

- Don't suggest whitespace changes.

## No Inventions

- Don't invent changes other than what's explicitly requested.

## No Unnecessary Confirmations

- Don't ask for confirmation of information already provided in the context, but always make sure wverything is understood before proceeding

## Preserve Existing Code

- Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.

## Single Chunk Edits

- Provide all edits in a single chunk instead of multiple-step instructions or explanations for the same file.

## No Implementation Checks

- Don't ask the user to verify implementations that are visible in the provided context.

## No Unnecessary Updates

- Don't suggest updates or changes to files when there are no actual modifications needed.

## Provide Real File Links

- Always provide links to the real files, not x.md.

## Project Structure

- Use the App Router directory structure
- Place components in `app` directory for route-specific components
- Place shared components in `components` directory
- Place utilities and helpers in `services` or `utils` directories depending on content

## Components

- Mark client components explicitly with 'use client'
- Implement proper error boundaries
- Place static content and interfaces at file end

## Data Fetching

- Use Server Components for data fetching when possible
- Implement proper error handling for data fetching
- Use appropriate caching strategies
- Handle loading and error states appropriately

## Component Structure

- Use functional components over class components
- Keep components small and focused
- Extract reusable logic into custom hooks
- Use composition over inheritance
- Implement proper prop types with TypeScript, and place them in `types` folder
- Split large components into smaller, focused ones

## Hooks

- Follow the Rules of Hooks
- Use custom hooks for reusable logic
- Keep hooks focused and simple
- Use appropriate dependency arrays in useEffect
- Implement cleanup in useEffect when needed
- Avoid nested hooks

## State Management

- Use useState for local component state
- Implement useReducer for complex state logic
- Use Context API for shared state
- Keep state as close to where it's used as possible
- Avoid prop drilling through proper state management

## Performance

- Implement proper memoization (useMemo, useCallback)
- Use React.memo for expensive components
- Avoid unnecessary re-renders
- Implement proper lazy loading
- Use proper key props in lists
- Profile and optimize render performance

## Error Handling

- Implement Error Boundaries
- Handle async errors properly
- Implement proper fallback UI
- Log errors appropriately
- Handle edge cases gracefully

## Type System

- Prefer interfaces over types for object definitions
- Use type for unions, intersections, and mapped types
- Avoid using `any`, prefer `unknown` for unknown types
- Use strict TypeScript configuration
- Leverage TypeScript's built-in utility types
- Use generics for reusable type patterns

## Naming Conventions

- Use PascalCase for type names and interfaces
- Use camelCase for variables and functions
- Use UPPER_CASE for constants
- Use descriptive names with auxiliary verbs (e.g., isLoading, hasError)
- Prefix interfaces for React props with 'Props' (e.g., ButtonProps)

## Code Organization

- Keep type definitions close to where they're used
- Export types and interfaces from dedicated type files when shared
- Place shared types in a `types` directory
- Co-locate component props with their components

## Functions

- Use explicit return types for public functions
- Use arrow functions for callbacks and methods
- Implement proper error handling with custom error types
- Use function overloads for complex type scenarios
- Prefer async/await over Promises

## Best Practices

- Enable strict mode in tsconfig.json
- Use readonly for immutable properties
- Leverage discriminated unions for type safety
- Use type guards for runtime type checking
- Implement proper null checking
- Avoid type assertions unless necessary
